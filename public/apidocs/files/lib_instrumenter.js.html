<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib&#x2F;instrumenter.js - The Istanbul API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="The Istanbul API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1-12</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/API.html">API</a></li>
            
                <li><a href="..&#x2F;classes/Collector.html">Collector</a></li>
            
                <li><a href="..&#x2F;classes/Hook.html">Hook</a></li>
            
                <li><a href="..&#x2F;classes/HtmlReport.html">HtmlReport</a></li>
            
                <li><a href="..&#x2F;classes/Instrumenter.html">Instrumenter</a></li>
            
                <li><a href="..&#x2F;classes/LcovOnlyReport.html">LcovOnlyReport</a></li>
            
                <li><a href="..&#x2F;classes/LcovReport.html">LcovReport</a></li>
            
                <li><a href="..&#x2F;classes/LookupStore.html">LookupStore</a></li>
            
                <li><a href="..&#x2F;classes/MemoryStore.html">MemoryStore</a></li>
            
                <li><a href="..&#x2F;classes/ObjectUtils.html">ObjectUtils</a></li>
            
                <li><a href="..&#x2F;classes/Report.html">Report</a></li>
            
                <li><a href="..&#x2F;classes/Store.html">Store</a></li>
            
                <li><a href="..&#x2F;classes/TextReport.html">TextReport</a></li>
            
                <li><a href="..&#x2F;classes/TextSummaryReport.html">TextSummaryReport</a></li>
            
                <li><a href="..&#x2F;classes/TmpStore.html">TmpStore</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/istanbul.html">istanbul</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib&#x2F;instrumenter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 Copyright (c) 2012, Yahoo! Inc.  All rights reserved.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 *&#x2F;

&#x2F;*global esprima, escodegen, window *&#x2F;
(function (isNode) {

    var SYNTAX,
        nodeType,
        ESP = isNode ? require(&#x27;esprima&#x27;) : esprima,
        ESPGEN = isNode ? require(&#x27;escodegen&#x27;) : escodegen,  &#x2F;&#x2F;TODO - package as dependency
        crypto = isNode ? require(&#x27;crypto&#x27;) : null,
        LEADER_WRAP = &#x27;(function () { &#x27;,
        TRAILER_WRAP = &#x27;\n}());&#x27;,
        astgen,
        preconditions,
        cond,
        isArray = Array.isArray;

    if (!isArray) {
        isArray = function (thing) { return thing &amp;&amp;  Object.prototype.toString.call(thing) === &#x27;[object Array]&#x27;; };
    }

    if (!isNode) {
        preconditions = {
            &#x27;Could not find esprima&#x27;: ESP,
            &#x27;Could not find escodegen&#x27;: ESPGEN,
            &#x27;JSON object not in scope&#x27;: JSON,
            &#x27;Array does not implement push&#x27;: [].push,
            &#x27;Array does not implement unshift&#x27;: [].unshift
        };
        for (cond in preconditions) {
            if (preconditions.hasOwnProperty(cond)) {
                if (!preconditions[cond]) { throw new Error(cond); }
            }
        }
    }

    function generateTrackerVar(filename, omitSuffix) {
        var hash, suffix;
        if (crypto !== null) {
            hash = crypto.createHash(&#x27;md5&#x27;);
            hash.update(filename);
            suffix = hash.digest(&#x27;base64&#x27;);
            &#x2F;&#x2F;trim trailing equal signs, turn identifier unsafe chars to safe ones + =&gt; _ and &#x2F; =&gt; $
            suffix = suffix.replace(new RegExp(&#x27;=&#x27;, &#x27;g&#x27;), &#x27;&#x27;)
                .replace(new RegExp(&#x27;\\+&#x27;, &#x27;g&#x27;), &#x27;_&#x27;)
                .replace(new RegExp(&#x27;&#x2F;&#x27;, &#x27;g&#x27;), &#x27;$&#x27;);
        } else {
            &#x2F;*jslint nomen: true *&#x2F;
            window.__cov_seq = window.__cov_seq || 0;
            window.__cov_seq += 1;
            suffix = window.__cov_seq;
        }
        return &#x27;__cov_&#x27; + (omitSuffix ? &#x27;&#x27; : suffix);
    }

    function pushAll(ary, thing) {
        if (!isArray(thing)) {
            thing = [ thing ];
        }
        Array.prototype.push.apply(ary, thing);
    }

    SYNTAX = {
        ArrayExpression: [ &#x27;elements&#x27; ],
        AssignmentExpression: [&#x27;left&#x27;, &#x27;right&#x27;],
        BinaryExpression: [&#x27;left&#x27;, &#x27;right&#x27; ],
        BlockStatement: [ &#x27;body&#x27; ],
        BreakStatement: [ &#x27;label&#x27; ],
        CallExpression: [ &#x27;callee&#x27;, &#x27;arguments&#x27;],
        CatchClause: [&#x27;param&#x27;, &#x27;body&#x27;],
        ConditionalExpression: [ &#x27;test&#x27;, &#x27;consequent&#x27;, &#x27;alternate&#x27; ],
        ContinueStatement: [ &#x27;label&#x27; ],
        DebuggerStatement: [ ],
        DoWhileStatement: [ &#x27;test&#x27;, &#x27;body&#x27; ],
        EmptyStatement: [],
        ExpressionStatement: [ &#x27;expression&#x27;],
        ForInStatement: [ &#x27;left&#x27;, &#x27;right&#x27;, &#x27;body&#x27; ],
        ForStatement: [&#x27;init&#x27;, &#x27;test&#x27;, &#x27;update&#x27;, &#x27;body&#x27; ],
        FunctionDeclaration: [&#x27;id&#x27;, &#x27;params&#x27;, &#x27;body&#x27;],
        FunctionExpression: [&#x27;id&#x27;, &#x27;params&#x27;, &#x27;defaults&#x27;, &#x27;body&#x27;],
        Identifier: [],
        IfStatement: [&#x27;test&#x27;, &#x27;consequent&#x27;, &#x27;alternate&#x27;],
        LabeledStatement: [&#x27;label&#x27;, &#x27;body&#x27;],
        Literal: [],
        LogicalExpression: [ &#x27;left&#x27;, &#x27;right&#x27; ],
        MemberExpression: [&#x27;object&#x27;, &#x27;property&#x27;],
        NewExpression: [&#x27;callee&#x27;, &#x27;arguments&#x27;],
        ObjectExpression: [ &#x27;properties&#x27; ],
        Program: [ &#x27;body&#x27; ],
        Property: [ &#x27;key&#x27;, &#x27;value&#x27;],
        ReturnStatement: [&#x27;argument&#x27;],
        SequenceExpression: [&#x27;expressions&#x27;],
        SwitchCase: [ &#x27;test&#x27;, &#x27;consequent&#x27; ],
        SwitchStatement: [&#x27;discriminant&#x27;, &#x27;cases&#x27; ],
        ThisExpression: [],
        ThrowStatement: [&#x27;argument&#x27;],
        TryStatement: [ &#x27;block&#x27;, &#x27;handlers&#x27;, &#x27;finalizer&#x27; ],
        UnaryExpression: [&#x27;argument&#x27;],
        UpdateExpression: [ &#x27;argument&#x27; ],
        VariableDeclaration: [ &#x27;declarations&#x27; ],
        VariableDeclarator: [ &#x27;id&#x27;, &#x27;init&#x27; ],
        WhileStatement: [ &#x27;test&#x27;, &#x27;body&#x27; ],
        WithStatement: [ &#x27;object&#x27;, &#x27;body&#x27; ]

    };

    for (nodeType in SYNTAX) {
        if (SYNTAX.hasOwnProperty(nodeType)) {
            SYNTAX[nodeType] = { name: nodeType, children: SYNTAX[nodeType] };
        }
    }

    astgen = {
        variable: function (name) { return { type: SYNTAX.Identifier.name, name: name }; },
        stringLiteral: function (str) { return { type: SYNTAX.Literal.name, value: String(str) }; },
        numericLiteral: function (num) { return { type: SYNTAX.Literal.name, value: Number(num) }; },
        statement: function (contents) { return { type: SYNTAX.ExpressionStatement.name, expression: contents }; },
        dot: function (obj, field) { return { type: SYNTAX.MemberExpression.name, computed: false, object: obj, property: field }; },
        subscript: function (obj, sub) { return { type: SYNTAX.MemberExpression.name, computed: true, object: obj, property: sub }; },
        postIncrement: function (obj) { return { type: SYNTAX.UpdateExpression.name, operator: &#x27;++&#x27;, prefix: false, argument: obj }; },
        sequence: function (one, two) { return { type: SYNTAX.SequenceExpression.name, expressions: [one, two] }; }
    };

    function Walker(walkMap, scope, debug) {
        this.walkMap = walkMap;
        this.scope = scope;
        this.debug = debug;
        if (this.debug) {
            this.level = 0;
            this.seq = true;
        }
    }

    function defaultWalker(node, walker) {

        var type = node.type,
            children = SYNTAX[type].children,
            applyCustomWalker = !!node.loc || node.type === SYNTAX.Program.name, &#x2F;&#x2F; don&#x27;t run generated nodes thru custom walks otherwise we will attempt to instrument the instrumentation code :)
            walkerFn = applyCustomWalker ? walker.walkMap[type] : null,
            i,
            j,
            walkFnIndex,
            childType,
            childNode,
            ret = node,
            childArray,
            childElement,
            tmpNode,
            pathElement,
            assignNode,
            isLast;

        if (node.walking) { throw new Error(&#x27;Infinite regress: Custom walkers may NOT call walker.walk(node)&#x27;); }
        node.walking = true;
        if (isArray(walkerFn)) {
            for (walkFnIndex = 0; walkFnIndex &lt; walkerFn.length; walkFnIndex += 1) {
                isLast = walkFnIndex === walkerFn.length - 1;
                ret = walker.walk(ret, walkerFn[walkFnIndex]) || ret;
                if (ret.type !== type &amp;&amp; !isLast) { throw new Error(&#x27;Only the last walker is allowed to change the node type: [type was: &#x27; + type + &#x27; ]&#x27;); }
            }
        } else {
            if (walkerFn) {
                ret = walker.walk(node, walkerFn) || ret;
            }
        }

        for (i = 0; i &lt; children.length; i += 1) {
            childType = children[i];
            childNode = node[childType];
            if (childNode &amp;&amp; !childNode.skipWalk) {
                pathElement = { node: node, property: childType };
                if (isArray(childNode)) {
                    childArray = [];
                    for (j = 0; j &lt; childNode.length; j += 1) {
                        childElement = childNode[j];
                        pathElement.index = j;
                        assignNode = walker.walk(childElement, null, pathElement) || childElement;
                        if (isArray(assignNode.prepend)) {
                            pushAll(childArray, assignNode.prepend);
                            delete assignNode.prepend;
                        }
                        pushAll(childArray, assignNode);
                    }
                    node[childType] = childArray;
                } else {
                    assignNode = walker.walk(childNode, null, pathElement) || childNode;
                    if (isArray(assignNode.prepend)) {
                        throw new Error(&#x27;Internal error: attempt to prepend statements in disallowed (non-array) context&#x27;);
                        &#x2F;* if this should be allowed, this is how to solve it
                        tmpNode = { type: &#x27;BlockStatement&#x27;, body: [] };
                        pushAll(tmpNode.body, assignNode.prepend);
                        pushAll(tmpNode.body, assignNode);
                        node[childType] = tmpNode;
                        delete assignNode.prepend;
                        *&#x2F;
                    } else {
                        node[childType] = assignNode;
                    }
                }
            }
        }

        delete node.walking;
        return ret;
    }

    Walker.prototype = {
        startWalk: function (node) {
            this.path = [];
            this.walk(node);
        },

        walk: function (node, walkFn, pathElement) {
            var ret, i, seq, prefix;

            walkFn = walkFn || defaultWalker;
            if (this.debug) {
                this.seq += 1;
                this.level += 1;
                seq = this.seq;
                prefix = &#x27;&#x27;;
                for (i = 0; i &lt; this.level; i += 1) { prefix += &#x27;    &#x27;; }
                console.log(prefix + &#x27;Enter (&#x27; + seq + &#x27;):&#x27; + node.type);
            }
            if (pathElement) { this.path.push(pathElement); }
            ret = walkFn.call(this.scope, node, this);
            if (pathElement) { this.path.pop(); }
            if (this.debug) {
                this.level -= 1;
                console.log(prefix + &#x27;Return (&#x27; + seq + &#x27;):&#x27; + node.type);
            }
            return ret;
        },

        startLineForNode: function (node) {
            return node &amp;&amp; node.loc &amp;&amp; node.loc.start ? node.loc.start.line : null;
        },

        parent: function () {
            return this.path.length &gt; 0 ? this.path[this.path.length - 1] : null;
        },

        isLabeled: function () {
            var el = this.parent();
            return el &amp;&amp; el.node.type === SYNTAX.LabeledStatement.name;
        }
    };

    &#x2F;**
     * mechanism to instrument code for coverage. It uses the &#x60;esprima&#x60; and
     * &#x60;escodegen&#x60; libraries for JS parsing and code generation respectively.
     *
     * Works on &#x60;node&#x60; as well as the browser.
     *
     * Usage on nodejs
     * ---------------
     *
     *      var instrumenter = new require(&#x27;istanbul&#x27;).Instrumenter(),
     *          changed = instrumenter.instrumentSync(&#x27;function meaningOfLife() { return 42; }&#x27;, &#x27;filename.js&#x27;);
     *
     * Usage in a browser
     * ------------------
     *
     * Load &#x60;esprima.js&#x60;, &#x60;escodegen.js&#x60; and &#x60;instrumenter.js&#x60; (this file) using &#x60;script&#x60; tags or other means.
     *
     * Create an instrumenter object as:
     *
     *      var instrumenter = new Instrumenter(),
     *          changed = instrumenter.instrumentSync(&#x27;function meaningOfLife() { return 42; }&#x27;, &#x27;filename.js&#x27;);
     *
     * Aside from demonstration purposes, it is unclear why you would want to instrument code in a browser.
     *
     * @class Instrumenter
     * @constructor
     * @param {Object} options Optional. Configuration options.
     * @param {String} [options.coverageVariable] the global variable name to use for
     *      tracking coverage. Defaults to &#x60;__coverage__&#x60;
     * @param {Boolean} [options.embedSource] whether to embed the source code of every
     *      file as an array in the file coverage object for that file. Defaults to &#x60;false&#x60;
     * @param {Boolean} [options.noCompact] emit readable code when set. Defaults to &#x60;false&#x60;
     * @param {Boolean} [options.noAutoWrap] do not automatically wrap the source in
     *      an anonymous function before covering it. By default, code is wrapped in
     *      an anonymous function before it is parsed. This is done because
     *      some nodejs libraries have &#x60;return&#x60; statements outside of
     *      a function which is technically invalid Javascript and causes the parser to fail.
     *      This construct, however, works correctly in node since module loading
     *      is done in the context of an anonymous function.
     *
     * Note that the semantics of the code *returned* by the instrumenter does not change in any way.
     * The function wrapper is &quot;unwrapped&quot; before the instrumented code is generated.
     * @param {Object} [options.codeGenerationOptions] an object that is directly passed to the &#x60;escodegen&#x60;
     *      library as configuration for code generation. The &#x60;noCompact&#x60; setting is not honored when this
     *      option is specified
     * @param {Boolean} [options.debug] assist in debugging. Currently, the only effect of
     *      setting this option is a pretty-print of the coverage variable. Defaults to &#x60;false&#x60;
     * @param {Boolean} [options.walkDebug] assist in debugging of the AST walker used by this class.
     *
     *&#x2F;
    function Instrumenter(options) {
        this.opts = options || {
            debug: false,
            walkDebug: false,
            coverageVariable: &#x27;__coverage__&#x27;,
            codeGenerationOptions: undefined,
            noAutoWrap: false,
            noCompact: false,
            embedSource: false
        };

        this.walker = new Walker({
            ExpressionStatement: this.coverStatement,
            BreakStatement: this.coverStatement,
            ContinueStatement: this.coverStatement,
            DebuggerStatement: this.coverStatement,
            ReturnStatement: this.coverStatement,
            ThrowStatement: this.coverStatement,
            TryStatement: this.coverStatement,
            VariableDeclaration: this.coverStatement,
            IfStatement: [ this.ifBlockConverter, this.ifBranchInjector, this.coverStatement ],
            ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
            ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
            WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
            DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
            SwitchStatement: [ this.switchBranchInjector, this.coverStatement ],
            WithStatement: this.coverStatement,
            FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
            FunctionExpression: this.coverFunction,
            LabeledStatement: this.coverStatement,
            ConditionalExpression: this.conditionalBranchInjector,
            LogicalExpression: this.logicalExpressionBranchInjector
        }, this, this.opts.walkDebug);

        &#x2F;&#x2F;unit testing purposes only
        if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
            this.omitTrackerSuffix = true;
        }
    }

    Instrumenter.prototype = {
        &#x2F;**
         * synchronous instrumentation method. Throws when illegal code is passed to it
         * @method instrumentSync
         * @param {String} code the code to be instrumented as a String
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         *&#x2F;
        instrumentSync: function (code, filename) {
            var codegenOptions,
                program;
            filename = filename || String(new Date().getTime()) + &#x27;.js&#x27;;
            this.coverState = {
                path: filename,
                s: {},
                b: {},
                f: {},
                fnMap: {},
                statementMap: {},
                branchMap: {}
            };
            this.currentState = {
                trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),
                func: 0,
                branch: 0,
                variable: 0,
                statement: 0
            };

            if (typeof code !== &#x27;string&#x27;) { throw new Error(&#x27;Code must be string&#x27;); } &#x2F;&#x2F;protect from users accidentally passing in a Buffer object instead
            if (code.charAt(0) === &#x27;#&#x27;) { &#x2F;&#x2F;shebang, &#x27;comment&#x27; it out, won&#x27;t affect syntax tree locations for things we care about
                code = &#x27;&#x2F;&#x2F;&#x27; + code;
            }
            if (!this.opts.noAutoWrap) {
                code = LEADER_WRAP + code + TRAILER_WRAP;
            }
            program = ESP.parse(code, { loc: true });
            if (!this.opts.noAutoWrap) {
                program = { type: SYNTAX.Program.name, body: program.body[0].expression.callee.body.body };
            }
            this.walker.startWalk(program);
            codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};
            &#x2F;&#x2F;console.log(JSON.stringify(program, undefined, 2));
            return this.getPreamble(code) + &#x27;\n&#x27; + ESPGEN.generate(program, codegenOptions) + &#x27;\n&#x27;;
        },
        &#x2F;**
         * Callback based instrumentation. Note that this still executes synchronously in the same process tick
         * and calls back immediately. It only provides the options for callback style error handling as
         * opposed to a &#x60;try-catch&#x60; style and nothing more. Implemented as a wrapper over &#x60;instrumentSync&#x60;
         *
         * @method instrument
         * @param {String} code the code to be instrumented as a String
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         * @param {Function(err, instrumentedCode)} callback - the callback function
         *&#x2F;
        instrument: function (code, filename, callback) {

            if (!callback &amp;&amp; typeof filename === &#x27;function&#x27;) {
                callback = filename;
                filename = null;
            }
            try {
                callback(null, this.instrumentSync(code, filename));
            } catch (ex) {
                callback(ex);
            }
        },

        fixColumnPositions: function (coverState) {
            var offset = LEADER_WRAP.length,
                fixer = function (loc) {
                    if (loc.start.line === 1) {
                        loc.start.column -= offset;
                    }
                    if (loc.end.line === 1) {
                        loc.end.column -= offset;
                    }
                },
                k,
                obj,
                i,
                locations;

            obj = coverState.statementMap;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) { fixer(obj[k]); }
            }
            obj = coverState.fnMap;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }
            }
            obj = coverState.branchMap;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    locations = obj[k].locations;
                    for (i = 0; i &lt; locations.length; i += 1) {
                        fixer(locations[i]);
                    }
                }
            }
        },

        getPreamble: function (sourceCode) {
            var varName = this.opts.coverageVariable || &#x27;__coverage__&#x27;,
                file = this.coverState.path.replace(&#x2F;\\&#x2F;g, &#x27;\\\\&#x27;),
                tracker = this.currentState.trackerVar,
                coverState,
                replacer = function (s) { &#x2F;&#x2F;return replacements using the function to ensure that the replacement is treated like a dumb string and not as a string with RE replacement patterns
                    return function () { return s; };
                },
                code;
            if (!this.opts.noAutoWrap) {
                this.fixColumnPositions(this.coverState);
            }
            if (this.opts.embedSource) {
                this.coverState.code = sourceCode.split(&#x2F;\n&#x2F;);
            }
            coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);
            code = [
                &quot;if (typeof %GLOBAL% === &#x27;undefined&#x27;) { %GLOBAL% = {}; }&quot;,
                &quot;if (!%GLOBAL%[&#x27;%FILE%&#x27;]) {&quot;,
                &quot;   %GLOBAL%[&#x27;%FILE%&#x27;] = %OBJECT%;&quot;,
                &quot;}&quot;,
                &quot;var %VAR% = %GLOBAL%[&#x27;%FILE%&#x27;];&quot;
            ].join(&quot;\n&quot;)
                .replace(&#x2F;%VAR%&#x2F;g, replacer(tracker))
                .replace(&#x2F;%GLOBAL%&#x2F;g, replacer(varName))
                .replace(&#x2F;%FILE%&#x2F;g, replacer(file))
                .replace(&#x2F;%OBJECT%&#x2F;g, replacer(coverState));
            return code;
        },

        convertToBlock: function (node) {
            if (!node) {
                return { type: &#x27;BlockStatement&#x27;, body: [] };
            } else if (node.type === &#x27;BlockStatement&#x27;) {
                return node;
            } else {
                return { type: &#x27;BlockStatement&#x27;, body: [ node ] };
            }
        },

        ifBlockConverter: function (node) {
            node.consequent = this.convertToBlock(node.consequent);
            node.alternate = this.convertToBlock(node.alternate);
        },

        loopBlockConverter: function (node) {
            node.body = this.convertToBlock(node.body);
        },

        statementName: function (location) {
            var sName;
            this.currentState.statement += 1;
            sName = this.currentState.statement;
            this.coverState.statementMap[sName] = location;
            this.coverState.s[sName] = 0;
            return sName;
        },

        skipInit: function (node, walker) {
            if (node.init) {
                node.init.skipWalk = true;
            }
        },

        skipLeft: function (node, walker) {
            node.left.skipWalk = true;
        },

        coverStatement: function (node, walker) {
            var sName,
                incrStatementCount;

            sName = this.statementName(node.loc);
            incrStatementCount = astgen.statement(
                astgen.postIncrement(
                    astgen.subscript(
                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&#x27;s&#x27;)),
                        astgen.stringLiteral(sName)
                    )
                )
            );
            this.splice(incrStatementCount, node, walker);
        },

        splice: function (statements, node, walker) {
            var targetNode = walker.isLabeled() ? walker.parent().node : node;
            targetNode.prepend = targetNode.prepend || [];
            pushAll(targetNode.prepend, statements);
        },

        functionName: function (node, line, location) {
            this.currentState.func += 1;
            var id = this.currentState.func,
                name = node.id ? node.id.name : &#x27;(anonymous_&#x27; + id + &#x27;)&#x27;;
            this.coverState.fnMap[id] = { name: name, line: line, loc: location };
            this.coverState.f[id] = 0;
            return id;
        },

        coverFunction: function (node, walker) {
            var id = this.functionName(node, walker.startLineForNode(node), { start: node.loc.start, end: { line: node.body.loc.start.line, column: node.body.loc.start.column } }),
                body = node.body,
                blockBody = body.body;
            blockBody.unshift(
                astgen.statement(
                    astgen.postIncrement(
                        astgen.subscript(
                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&#x27;f&#x27;)),
                            astgen.stringLiteral(id)
                        )
                    )
                )
            );
        },

        branchName: function (type, startLine, pathLocations) {
            var bName,
                paths = [],
                locations = [],
                i;
            this.currentState.branch += 1;
            bName = this.currentState.branch;
            for (i = 0; i &lt; pathLocations.length; i += 1) {
                paths.push(0);
                locations.push(pathLocations[i]);
            }
            this.coverState.b[bName] = paths;
            this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };
            return bName;
        },

        branchIncrementExprAst: function (varName, branchIndex, down) {
            var ret = astgen.postIncrement(
                astgen.subscript(
                    astgen.subscript(
                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&#x27;b&#x27;)),
                        astgen.stringLiteral(varName)
                    ),
                    astgen.numericLiteral(branchIndex)
                ),
                down
            );
            return ret;
        },

        locationsForNodes: function (nodes) {
            var ret = [],
                i;
            for (i = 0; i &lt; nodes.length; i += 1) {
                ret.push(nodes[i].loc);
            }
            return ret;
        },

        ifBranchInjector: function (node, walker) {
            var line = node.loc.start.line,
                col = node.loc.start.column,
                start = { line: line, column: col },
                end = { line: line, column: col },
                bName = this.branchName(&#x27;if&#x27;, walker.startLineForNode(node), [
                    { start: start, end: end },
                    { start: start, end: end }
                ]),
                thenBody = node.consequent.body,
                elseBody = node.alternate.body;
            thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));
            elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));
        },

        switchBranchInjector: function (node, walker) {
            var cases = node.cases,
                bName,
                i;

            if (!cases) {
                return;
            }
            bName = this.branchName(&#x27;switch&#x27;, walker.startLineForNode(node), this.locationsForNodes(cases));
            for (i = 0; i &lt; cases.length; i += 1) {
                cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));
            }
        },

        conditionalBranchInjector: function (node, walker) {
            var bName = this.branchName(&#x27;cond-expr&#x27;, walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate ])),
                ast1 = this.branchIncrementExprAst(bName, 0),
                ast2 = this.branchIncrementExprAst(bName, 1);

            node.consequent = astgen.sequence(ast1, node.consequent);
            node.alternate = astgen.sequence(ast2, node.alternate);
        },

        logicalExpressionBranchInjector: function (node, walker) {
            var parent = walker.parent(),
                leaves = [],
                bName,
                tuple,
                i;

            if (parent &amp;&amp; parent.node.type === SYNTAX.LogicalExpression.name) {
                &#x2F;&#x2F;already covered
                return;
            }

            this.findLeaves(node, leaves);
            bName = this.branchName(&#x27;binary-expr&#x27;, walker.startLineForNode(node), this.locationsForNodes(leaves.map(function (item) { return item.node; })));
            for (i = 0; i &lt; leaves.length; i += 1) {
                tuple = leaves[i];
                tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);
            }
        },

        findLeaves: function (node, accumulator, parent, property) {
            if (node.type === SYNTAX.LogicalExpression.name) {
                this.findLeaves(node.left, accumulator, node, &#x27;left&#x27;);
                this.findLeaves(node.right, accumulator, node, &#x27;right&#x27;);
            } else {
                accumulator.push({ node: node, parent: parent, property: property });
            }
        }
    };

    if (isNode) {
        module.exports = Instrumenter;
    } else {
        window.Instrumenter = Instrumenter;
    }

}(typeof module !== &#x27;undefined&#x27; &amp;&amp; typeof module.exports !== &#x27;undefined&#x27; &amp;&amp; typeof exports !== &#x27;undefined&#x27;));


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
