{
    "project": {
        "name": "The Istanbul API",
        "description": "The Istanbul API: a code coverage library",
        "version": "0.2.0"
    },
    "files": {
        "lib/command/instrument.js": {
            "name": "lib/command/instrument.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib/report/cobertura.js": {
            "name": "lib/report/cobertura.js",
            "modules": {},
            "classes": {
                "CoberturaReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/html.js": {
            "name": "lib/report/html.js",
            "modules": {},
            "classes": {
                "HtmlReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/index.js": {
            "name": "lib/report/index.js",
            "modules": {},
            "classes": {
                "Report": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/json.js": {
            "name": "lib/report/json.js",
            "modules": {},
            "classes": {
                "JsonReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/lcov.js": {
            "name": "lib/report/lcov.js",
            "modules": {},
            "classes": {
                "LcovReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/lcovonly.js": {
            "name": "lib/report/lcovonly.js",
            "modules": {},
            "classes": {
                "LcovOnlyReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/teamcity.js": {
            "name": "lib/report/teamcity.js",
            "modules": {},
            "classes": {
                "TeamcityReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/text-summary.js": {
            "name": "lib/report/text-summary.js",
            "modules": {},
            "classes": {
                "TextSummaryReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/report/text.js": {
            "name": "lib/report/text.js",
            "modules": {},
            "classes": {
                "TextReport": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/store/fslookup.js": {
            "name": "lib/store/fslookup.js",
            "modules": {},
            "classes": {
                "LookupStore": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/store/index.js": {
            "name": "lib/store/index.js",
            "modules": {},
            "classes": {
                "Store": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/store/memory.js": {
            "name": "lib/store/memory.js",
            "modules": {},
            "classes": {
                "MemoryStore": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/store/tmp.js": {
            "name": "lib/store/tmp.js",
            "modules": {},
            "classes": {
                "TmpStore": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/util/flow-control.js": {
            "name": "lib/util/flow-control.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib/util/writer.js": {
            "name": "lib/util/writer.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib/collector.js": {
            "name": "lib/collector.js",
            "modules": {},
            "classes": {
                "Collector": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/hook.js": {
            "name": "lib/hook.js",
            "modules": {},
            "classes": {
                "Hook": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/instrumenter.js": {
            "name": "lib/instrumenter.js",
            "modules": {},
            "classes": {
                "Instrumenter": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "lib/object-utils.js": {
            "name": "lib/object-utils.js",
            "modules": {},
            "classes": {
                "ObjectUtils": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "misc/samples/coverage.js": {
            "name": "misc/samples/coverage.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "index.js": {
            "name": "index.js",
            "modules": {
                "istanbul": 1
            },
            "classes": {
                "API": 1
            },
            "fors": {},
            "namespaces": {}
        }
    },
    "modules": {
        "istanbul": {
            "name": "istanbul",
            "submodules": {},
            "classes": {
                "CoberturaReport": 1,
                "HtmlReport": 1,
                "Report": 1,
                "JsonReport": 1,
                "LcovReport": 1,
                "LcovOnlyReport": 1,
                "TeamcityReport": 1,
                "TextSummaryReport": 1,
                "TextReport": 1,
                "LookupStore": 1,
                "Store": 1,
                "MemoryStore": 1,
                "TmpStore": 1,
                "Collector": 1,
                "Hook": 1,
                "Instrumenter": 1,
                "ObjectUtils": 1,
                "API": 1
            },
            "fors": {},
            "namespaces": {},
            "tag": "module",
            "file": "index.js",
            "line": 23,
            "description": "provides access to the key libraries in istanbul so you can write\nyour own tools using `istanbul` as a library."
        }
    },
    "classes": {
        "CoberturaReport": {
            "name": "CoberturaReport",
            "shortname": "CoberturaReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/cobertura.js",
            "line": 12,
            "description": "a `Report` implementation that produces a cobertura-style XML file that conforms to the\nhttp://cobertura.sourceforge.net/xml/coverage-04.dtd DTD.\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('cobertura');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to the cobertura-coverage.xml will be written",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "HtmlReport": {
            "name": "HtmlReport",
            "shortname": "HtmlReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/html.js",
            "line": 308,
            "description": "a `Report` implementation that produces HTML coverage reports.\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('html');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to generate reports. Defaults to `./html-report`",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "Report": {
            "name": "Report",
            "shortname": "Report",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/index.js",
            "line": 8,
            "description": "abstract report class for producing coverage reports.\n\nUsage\n-----\n\n     var Report = require('istanbul').Report,\n         report = Report.create('html'),\n         collector = new require('istanbul').Collector;\n\n     collector.add(coverageObject);\n     report.writeReport(collector);",
            "is_constructor": 1,
            "access": "protected",
            "tagname": "",
            "params": [
                {
                    "name": "options",
                    "description": "Optional. The options supported by a specific store implementation.",
                    "type": "Object"
                }
            ]
        },
        "JsonReport": {
            "name": "JsonReport",
            "shortname": "JsonReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/json.js",
            "line": 10,
            "description": "a `Report` implementation that produces a coverage JSON object.\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('json');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to write the `coverage-final.json` file. Defaults to `process.cwd()`",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "LcovReport": {
            "name": "LcovReport",
            "shortname": "LcovReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/lcov.js",
            "line": 12,
            "description": "a `Report` implementation that produces an LCOV coverage file and an associated HTML report from coverage objects.\nThe name and behavior of this report is designed to ease migration for projects that currently use `yuitest_coverage`\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('lcov');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to the `lcov.info` file.\n HTML files are written in a subdirectory called `lcov-report`. Defaults to `process.cwd()`",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "LcovOnlyReport": {
            "name": "LcovOnlyReport",
            "shortname": "LcovOnlyReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/lcovonly.js",
            "line": 11,
            "description": "a `Report` implementation that produces an LCOV coverage file from coverage objects.\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('lcovonly');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to the `lcov.info` file. Defaults to `process.cwd()`",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "TeamcityReport": {
            "name": "TeamcityReport",
            "shortname": "TeamcityReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/teamcity.js",
            "line": 12,
            "description": "a `Report` implementation that produces system messages interpretable by TeamCity.\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('teamcity');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to the text coverage report will be written, when writing to a file",
                            "type": "String",
                            "optional": true
                        },
                        {
                            "name": "file",
                            "description": "the filename for the report. When omitted, the report is written to console",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "TextSummaryReport": {
            "name": "TextSummaryReport",
            "shortname": "TextSummaryReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/text-summary.js",
            "line": 12,
            "description": "a `Report` implementation that produces text output for overall coverage in summary format.\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('text-summary');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to the text coverage report will be written, when writing to a file",
                            "type": "String",
                            "optional": true
                        },
                        {
                            "name": "file",
                            "description": "the filename for the report. When omitted, the report is written to console",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "TextReport": {
            "name": "TextReport",
            "shortname": "TextReport",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/report/text.js",
            "line": 17,
            "description": "a `Report` implementation that produces text output in a detailed table.\n\nUsage\n-----\n\n     var report = require('istanbul').Report.create('text');",
            "extends": "Report",
            "is_constructor": 1,
            "params": [
                {
                    "name": "opts",
                    "description": "optional",
                    "type": "Object",
                    "props": [
                        {
                            "name": "dir",
                            "description": "the directory in which to the text coverage report will be written, when writing to a file",
                            "type": "String",
                            "optional": true
                        },
                        {
                            "name": "file",
                            "description": "the filename for the report. When omitted, the report is written to console",
                            "type": "String",
                            "optional": true
                        },
                        {
                            "name": "maxcols",
                            "description": "the max column width of the report. By default, the width of the report is adjusted based on the length of the paths\n             to be reported.",
                            "type": "Number",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "LookupStore": {
            "name": "LookupStore",
            "shortname": "LookupStore",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/store/fslookup.js",
            "line": 10,
            "description": "a `Store` implementation that doesn't actually store anything. It assumes that keys\nare absolute file paths, and contents are contents of those files.\nThus, `set` for this store is no-op, `get` returns the\ncontents of the filename that the key represents, `hasKey` returns true if the key\nsupplied is a valid file path and `keys` always returns an empty array.\n\nUsage\n-----\n\n     var store = require('istanbul').Store.create('fslookup');",
            "extends": "Store",
            "is_constructor": 1
        },
        "Store": {
            "name": "Store",
            "shortname": "Store",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/store/index.js",
            "line": 8,
            "description": "An abstraction for keeping track of content against some keys (e.g.\noriginal source, instrumented source, coverage objects against file names).\nThis class is both the base class as well as a factory for `Store` implementations.\n\nUsage\n-----\n\n     var Store = require('istanbul').Store,\n         store = Store.create('memory');\n\n     //basic use\n     store.set('foo', 'foo-content');\n     var content = store.get('foo');\n\n     //keys and values\n     store.keys().forEach(function (key) {\n         console.log(key + ':\\n' + store.get(key);\n     });\n     if (store.hasKey('bar') { console.log(store.get('bar'); }\n\n\n     //syntactic sugar\n     store.setObject('foo', { foo: true });\n     console.log(store.getObject('foo').foo);\n\n     store.dispose();",
            "is_constructor": 1,
            "access": "protected",
            "tagname": "",
            "params": [
                {
                    "name": "options",
                    "description": "Optional. The options supported by a specific store implementation.",
                    "type": "Object"
                }
            ]
        },
        "MemoryStore": {
            "name": "MemoryStore",
            "shortname": "MemoryStore",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/store/memory.js",
            "line": 9,
            "description": "a `Store` implementation using an in-memory object.\n\nUsage\n-----\n\n     var store = require('istanbul').Store.create('memory');",
            "extends": "Store",
            "is_constructor": 1
        },
        "TmpStore": {
            "name": "TmpStore",
            "shortname": "TmpStore",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/store/tmp.js",
            "line": 18,
            "description": "a `Store` implementation using temporary files.\n\nUsage\n-----\n\n     var store = require('istanbul').Store.create('tmp');",
            "extends": "Store",
            "params": [
                {
                    "name": "opts",
                    "description": "Optional.",
                    "type": "Object",
                    "props": [
                        {
                            "name": "tmp",
                            "description": "a pre-existing directory to use as the `tmp` directory. When not specified, a random directory\n     is created under `os.tmpDir()`",
                            "type": "String",
                            "optional": true
                        }
                    ]
                }
            ],
            "is_constructor": 1
        },
        "Collector": {
            "name": "Collector",
            "shortname": "Collector",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/collector.js",
            "line": 9,
            "description": "a mechanism to merge multiple coverage objects into one. Handles the use case\nof overlapping coverage information for the same files in multiple coverage\nobjects and does not double-count in this situation. For example, if\nyou pass the same coverage object multiple times, the final merged object will be\nno different that any of the objects passed in (except for execution counts).\n\nThe `Collector` is built for scale to handle thousands of coverage objects.\nBy default, all processing is done in memory since the common use-case is of\none or a few coverage objects. You can work around memory\nissues by passing in a `Store` implementation that stores temporary computations\non disk (the `tmp` store, for example).\n\nThe `getFinalCoverage` method returns an object with merged coverage information\nand is provided as a convenience for implementors working with coverage information\nthat can fit into memory. Reporters, in the interest of generality, should *not* use this method for\ncreating reports.\n\nUsage\n-----\n\n     var collector = new require('istanbul').Collector();\n\n     files.forEach(function (f) {\n         //each coverage object can have overlapping information about multiple files\n         collector.add(JSON.parse(fs.readFileSync(f, 'utf8')));\n     });\n\n     collector.files().forEach(function(file) {\n         var fileCoverage = collector.fileCoverageFor(file);\n         console.log('Coverage for ' + file + ' is:' + JSON.stringify(fileCoverage));\n     });\n\n     // convenience method: do not use this when dealing with a large number of files\n     var finalCoverage = collector.getFinalCoverage();",
            "is_constructor": 1,
            "params": [
                {
                    "name": "options",
                    "description": "Optional. Configuration options.",
                    "type": "Object",
                    "props": [
                        {
                            "name": "store",
                            "description": "- an implementation of `Store` to use for temporary\n     calculations.",
                            "type": "Store"
                        }
                    ]
                }
            ]
        },
        "Hook": {
            "name": "Hook",
            "shortname": "Hook",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/hook.js",
            "line": 6,
            "description": "provides a mechanism to transform code in the scope of `require` or `vm.createScript`.\nThis mechanism is general and relies on a user-supplied `matcher` function that determines when transformations should be\nperformed and a user-supplied `transformer` function that performs the actual transform.\nInstrumenting code for coverage is one specific example of useful hooking.\n\nNote that both the `matcher` and `transformer` must execute synchronously.\n\nFor the common case of matching filesystem paths based on inclusion/ exclusion patterns, use the `matcherFor`\nfunction in the istanbul API to get a matcher.\n\nIt is up to the transformer to perform processing with side-effects, such as caching, storing the original\nsource code to disk in case of dynamically generated scripts etc. The `Store` class can help you with this.\n\nUsage\n-----\n\n     var hook = require('istanbul').hook,\n         myMatcher = function (file) { return file.match(/foo/); },\n         myTransformer = function (code, file) { return 'console.log(\"' + file + '\");' + code; };\n\n     hook.hookRequire(myMatcher, myTransformer);\n\n     var foo = require('foo'); //will now print foo's module path to console"
        },
        "Instrumenter": {
            "name": "Instrumenter",
            "shortname": "Instrumenter",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/instrumenter.js",
            "line": 285,
            "description": "mechanism to instrument code for coverage. It uses the `esprima` and\n`escodegen` libraries for JS parsing and code generation respectively.\n\nWorks on `node` as well as the browser.\n\nUsage on nodejs\n---------------\n\n     var instrumenter = new require('istanbul').Instrumenter(),\n         changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');\n\nUsage in a browser\n------------------\n\nLoad `esprima.js`, `escodegen.js` and `instrumenter.js` (this file) using `script` tags or other means.\n\nCreate an instrumenter object as:\n\n     var instrumenter = new Instrumenter(),\n         changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');\n\nAside from demonstration purposes, it is unclear why you would want to instrument code in a browser.",
            "is_constructor": 1,
            "params": [
                {
                    "name": "options",
                    "description": "Optional. Configuration options.",
                    "type": "Object",
                    "props": [
                        {
                            "name": "coverageVariable",
                            "description": "the global variable name to use for\n     tracking coverage. Defaults to `__coverage__`",
                            "type": "String",
                            "optional": true
                        },
                        {
                            "name": "embedSource",
                            "description": "whether to embed the source code of every\n     file as an array in the file coverage object for that file. Defaults to `false`",
                            "type": "Boolean",
                            "optional": true
                        },
                        {
                            "name": "preserveComments",
                            "description": "whether comments should be preserved in the output. Defaults to `false`",
                            "type": "Boolean",
                            "optional": true
                        },
                        {
                            "name": "noCompact",
                            "description": "emit readable code when set. Defaults to `false`",
                            "type": "Boolean",
                            "optional": true
                        },
                        {
                            "name": "noAutoWrap",
                            "description": "do not automatically wrap the source in\n     an anonymous function before covering it. By default, code is wrapped in\n     an anonymous function before it is parsed. This is done because\n     some nodejs libraries have `return` statements outside of\n     a function which is technically invalid Javascript and causes the parser to fail.\n     This construct, however, works correctly in node since module loading\n     is done in the context of an anonymous function.\n\nNote that the semantics of the code *returned* by the instrumenter does not change in any way.\nThe function wrapper is \"unwrapped\" before the instrumented code is generated.",
                            "type": "Boolean",
                            "optional": true
                        },
                        {
                            "name": "codeGenerationOptions",
                            "description": "an object that is directly passed to the `escodegen`\n     library as configuration for code generation. The `noCompact` setting is not honored when this\n     option is specified",
                            "type": "Object",
                            "optional": true
                        },
                        {
                            "name": "debug",
                            "description": "assist in debugging. Currently, the only effect of\n     setting this option is a pretty-print of the coverage variable. Defaults to `false`",
                            "type": "Boolean",
                            "optional": true
                        },
                        {
                            "name": "walkDebug",
                            "description": "assist in debugging of the AST walker used by this class.",
                            "type": "Boolean",
                            "optional": true
                        }
                    ]
                }
            ]
        },
        "ObjectUtils": {
            "name": "ObjectUtils",
            "shortname": "ObjectUtils",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "file": "lib/object-utils.js",
            "line": 6,
            "description": "utility methods to process coverage objects. A coverage object has the following\nformat.\n\n     {\n         \"/path/to/file1.js\": { file1 coverage },\n         \"/path/to/file2.js\": { file2 coverage }\n     }\n\n The internals of the file coverage object are intentionally not documented since\n it is not a public interface.\n\n *Note:* When a method of this module has the word `File` in it, it will accept\n one of the sub-objects of the main coverage object as an argument. Other\n methods accept the higher level coverage object with multiple keys.\n\nWorks on `node` as well as the browser.\n\nUsage on nodejs\n---------------\n\n     var objectUtils = require('istanbul').utils;\n\nUsage in a browser\n------------------\n\nLoad this file using a `script` tag or other means. This will set `window.coverageUtils`\nto this module's exports.",
            "static": 1
        },
        "API": {
            "name": "API",
            "shortname": "API",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "istanbul",
            "namespace": "",
            "file": "index.js",
            "line": 23,
            "description": "the top-level API for `istanbul`.\n\nUsage\n-----\n\n     var istanbul = require('istanbul');"
        }
    },
    "classitems": [
        {
            "file": "lib/command/instrument.js",
            "line": 22,
            "description": "Chunk file size to use when reading non JavaScript files in memory\nand copying them over when using complete-copy flag.",
            "class": "CoberturaReport"
        },
        {
            "file": "lib/report/index.js",
            "line": 30,
            "description": "registers a new report implementation.",
            "itemtype": "method",
            "name": "register",
            "static": 1,
            "params": [
                {
                    "name": "constructor",
                    "description": "the constructor function for the report. This function must have a\n `TYPE` property of type String, that will be used in `Report.create()`",
                    "type": "Function"
                }
            ],
            "class": "Report"
        },
        {
            "file": "lib/report/index.js",
            "line": 37,
            "description": "returns a report implementation of the specified type.",
            "itemtype": "method",
            "name": "create",
            "static": 1,
            "params": [
                {
                    "name": "type",
                    "description": "the type of report to create",
                    "type": "String"
                },
                {
                    "name": "opts",
                    "description": "Optional. Options specific to the report implementation",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a new store of the specified type",
                "type": "Report"
            },
            "class": "Report"
        },
        {
            "file": "lib/report/index.js",
            "line": 47,
            "description": "writes the report for a set of coverage objects added to a collector.",
            "itemtype": "method",
            "name": "writeReport",
            "params": [
                {
                    "name": "collector",
                    "description": "the collector for getting the set of files and coverage",
                    "type": "Collector"
                },
                {
                    "name": "sync",
                    "description": "true if reports must be written synchronously, false if they can be written using asynchronous means (e.g. stream.write)",
                    "type": "Boolean"
                }
            ],
            "class": "Report"
        },
        {
            "file": "lib/store/index.js",
            "line": 46,
            "description": "registers a new store implementation.",
            "itemtype": "method",
            "name": "register",
            "static": 1,
            "params": [
                {
                    "name": "constructor",
                    "description": "the constructor function for the store. This function must have a\n `TYPE` property of type String, that will be used in `Store.create()`",
                    "type": "Function"
                }
            ],
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 53,
            "description": "returns a store implementation of the specified type.",
            "itemtype": "method",
            "name": "create",
            "static": 1,
            "params": [
                {
                    "name": "type",
                    "description": "the type of store to create",
                    "type": "String"
                },
                {
                    "name": "opts",
                    "description": "Optional. Options specific to the store implementation",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a new store of the specified type",
                "type": "Store"
            },
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 63,
            "description": "sets some content associated with a specific key. The manner in which\nduplicate keys are handled for multiple `set()` calls with the same\nkey is implementation-specific.",
            "itemtype": "method",
            "name": "set",
            "params": [
                {
                    "name": "key",
                    "description": "the key for the content",
                    "type": "String"
                },
                {
                    "name": "contents",
                    "description": "the contents for the key",
                    "type": "String"
                }
            ],
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 73,
            "description": "returns the content associated to a specific key or throws if the key\nwas not `set`",
            "itemtype": "method",
            "name": "get",
            "params": [
                {
                    "name": "key",
                    "description": "the key for which to get the content",
                    "type": "String"
                }
            ],
            "return": {
                "description": "the content for the specified key",
                "type": "String"
            },
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 81,
            "description": "returns a list of all known keys",
            "itemtype": "method",
            "name": "keys",
            "return": {
                "description": "an array of seen keys",
                "type": "Array"
            },
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 87,
            "description": "returns true if the key is one for which a `get()` call would work.",
            "itemtype": "method",
            "name": "hasKey",
            "params": [
                {
                    "name": "key",
                    "description": "",
                    "type": "String"
                }
            ],
            "return": {
                "description": "true if the key is valid for this store, false otherwise"
            },
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 94,
            "description": "lifecycle method to dispose temporary resources associated with the store",
            "itemtype": "method",
            "name": "dispose",
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 99,
            "description": "sugar method to return an object associated with a specific key. Throws\nif the content set against the key was not a valid JSON string.",
            "itemtype": "method",
            "name": "getObject",
            "params": [
                {
                    "name": "key",
                    "description": "the key for which to return the associated object",
                    "type": "String"
                }
            ],
            "return": {
                "description": "the object corresponding to the key",
                "type": "Object"
            },
            "class": "Store"
        },
        {
            "file": "lib/store/index.js",
            "line": 109,
            "description": "sugar method to set an object against a specific key.",
            "itemtype": "method",
            "name": "setObject",
            "params": [
                {
                    "name": "key",
                    "description": "the key for the object",
                    "type": "String"
                },
                {
                    "name": "object",
                    "description": "the object to be stored",
                    "type": "Object"
                }
            ],
            "class": "Store"
        },
        {
            "file": "lib/util/flow-control.js",
            "line": 7,
            "description": "Wrap a function and make sure it's called only once.",
            "params": [
                {
                    "name": "func",
                    "description": "Function to wrap.",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "Wrapped function.",
                "type": "Function"
            },
            "class": "Collector"
        },
        {
            "file": "lib/util/writer.js",
            "line": 34,
            "description": "allows writing content to a file using a callback that is passed a content writer",
            "params": [
                {
                    "name": "file",
                    "description": "the name of the file to write"
                },
                {
                    "name": "callback",
                    "description": "the callback that is called as `callback(contentWriter)`"
                }
            ],
            "class": "Collector"
        },
        {
            "file": "lib/util/writer.js",
            "line": 42,
            "description": "copies a file from source to destination",
            "params": [
                {
                    "name": "source",
                    "description": "the file to copy, found on the file system"
                },
                {
                    "name": "dest",
                    "description": "the destination path"
                }
            ],
            "class": "Collector"
        },
        {
            "file": "lib/util/writer.js",
            "line": 50,
            "description": "marker method to indicate that the caller is done with this writer object\nThe writer is expected to emit a `done` event only after this method is called\nand it is truly done.",
            "class": "Collector"
        },
        {
            "file": "lib/collector.js",
            "line": 57,
            "description": "adds a coverage object to the collector.",
            "itemtype": "method",
            "name": "add",
            "params": [
                {
                    "name": "coverage",
                    "description": "the coverage object.",
                    "type": "Object"
                },
                {
                    "name": "testName",
                    "description": "Optional. The name of the test used to produce the object.\n     This is currently not used.",
                    "type": "String"
                }
            ],
            "class": "Collector"
        },
        {
            "file": "lib/collector.js",
            "line": 76,
            "description": "returns a list of unique file paths for which coverage information has been added.",
            "itemtype": "method",
            "name": "files",
            "return": {
                "description": "an array of file paths for which coverage information is present.",
                "type": "Array"
            },
            "class": "Collector"
        },
        {
            "file": "lib/collector.js",
            "line": 84,
            "description": "return file coverage information for a single file",
            "itemtype": "method",
            "name": "fileCoverageFor",
            "params": [
                {
                    "name": "fileName",
                    "description": "the path for the file for which coverage information is\n     required. Must be one of the values returned in the `files()` method.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "the coverage information for the specified file.",
                "type": "Object"
            },
            "class": "Collector"
        },
        {
            "file": "lib/collector.js",
            "line": 96,
            "description": "returns file coverage information for all files. This has the same format as\nany of the objects passed in to the `add` method. The number of keys in this\nobject will be a superset of all keys found in the objects passed to `add()`",
            "itemtype": "method",
            "name": "getFinalCoverage",
            "return": {
                "description": "the merged coverage information",
                "type": "Object"
            },
            "class": "Collector"
        },
        {
            "file": "lib/collector.js",
            "line": 111,
            "description": "disposes this collector and reclaims temporary resources used in the\ncomputation. Calls `dispose()` on the underlying store.",
            "itemtype": "method",
            "name": "dispose",
            "class": "Collector"
        },
        {
            "file": "lib/hook.js",
            "line": 76,
            "description": "hooks `require` to return transformed code to the node module loader.\nExceptions in the transform result in the original code being used instead.",
            "itemtype": "method",
            "name": "hookRequire",
            "static": 1,
            "params": [
                {
                    "name": "matcher",
                    "description": "a function that is called with the absolute path to the file being\n `require`-d. Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise",
                    "type": "Function(filePath)"
                },
                {
                    "name": "transformer",
                    "description": "a function called with the original code and the associated path of the file\n from where the code was loaded. Should return the transformed code.",
                    "type": "Function(code, filePath)"
                },
                {
                    "name": "options",
                    "description": "options Optional.",
                    "type": "Object",
                    "props": [
                        {
                            "name": "verbose",
                            "description": "write a line to standard error every time the transformer is called",
                            "type": "Boolean",
                            "optional": true
                        },
                        {
                            "name": "postLoadHook",
                            "description": "a function that is called with the name of the file being\n required. This is called after the require is processed irrespective of whether it was transformed.",
                            "type": "Function",
                            "optional": true
                        }
                    ]
                }
            ],
            "class": "Hook"
        },
        {
            "file": "lib/hook.js",
            "line": 108,
            "description": "unhook `require` to restore it to its original state.",
            "itemtype": "method",
            "name": "unhookRequire",
            "static": 1,
            "class": "Hook"
        },
        {
            "file": "lib/hook.js",
            "line": 116,
            "description": "hooks `vm.createScript` to return transformed code out of which a `Script` object will be created.\nExceptions in the transform result in the original code being used instead.",
            "itemtype": "method",
            "name": "hookCreateScript",
            "static": 1,
            "params": [
                {
                    "name": "matcher",
                    "description": "a function that is called with the filename passed to `vm.createScript`\n Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise",
                    "type": "Function(filePath)"
                },
                {
                    "name": "transformer",
                    "description": "a function called with the original code and the filename passed to\n `vm.createScript`. Should return the transformed code.",
                    "type": "Function(code, filePath)"
                },
                {
                    "name": "options",
                    "description": "options Optional.",
                    "type": "Object",
                    "props": [
                        {
                            "name": "verbose",
                            "description": "write a line to standard error every time the transformer is called",
                            "type": "Boolean",
                            "optional": true
                        }
                    ]
                }
            ],
            "class": "Hook"
        },
        {
            "file": "lib/hook.js",
            "line": 137,
            "description": "unhooks vm.createScript, restoring it to its original state.",
            "itemtype": "method",
            "name": "unhookCreateScript",
            "static": 1,
            "class": "Hook"
        },
        {
            "file": "lib/hook.js",
            "line": 147,
            "description": "hooks `vm.runInThisContext` to return transformed code.",
            "itemtype": "method",
            "name": "hookRunInThisContext",
            "static": 1,
            "params": [
                {
                    "name": "matcher",
                    "description": "a function that is called with the filename passed to `vm.createScript`\n Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise",
                    "type": "Function(filePath)"
                },
                {
                    "name": "transformer",
                    "description": "a function called with the original code and the filename passed to\n `vm.createScript`. Should return the transformed code.",
                    "type": "Function(code, filePath)"
                },
                {
                    "name": "options",
                    "description": "options Optional.",
                    "type": "Object",
                    "props": [
                        {
                            "name": "verbose",
                            "description": "write a line to standard error every time the transformer is called",
                            "type": "Boolean",
                            "optional": true
                        }
                    ]
                }
            ],
            "class": "Hook"
        },
        {
            "file": "lib/hook.js",
            "line": 167,
            "description": "unhooks vm.runInThisContext, restoring it to its original state.",
            "itemtype": "method",
            "name": "unhookRunInThisContext",
            "static": 1,
            "class": "Hook"
        },
        {
            "file": "lib/instrumenter.js",
            "line": 380,
            "description": "synchronous instrumentation method. Throws when illegal code is passed to it",
            "itemtype": "method",
            "name": "instrumentSync",
            "params": [
                {
                    "name": "code",
                    "description": "the code to be instrumented as a String",
                    "type": "String"
                },
                {
                    "name": "filename",
                    "description": "Optional. The name of the file from which\n the code was read. A temporary filename is generated when not specified.\n Not specifying a filename is only useful for unit tests and demonstrations\n of this library.",
                    "type": "String"
                }
            ],
            "class": "Instrumenter"
        },
        {
            "file": "lib/instrumenter.js",
            "line": 456,
            "description": "synchronous instrumentation method that instruments an AST instead.",
            "itemtype": "method",
            "name": "instrumentASTSync",
            "params": [
                {
                    "name": "program",
                    "description": "the AST to be instrumented",
                    "type": "String"
                },
                {
                    "name": "filename",
                    "description": "Optional. The name of the file from which\n the code was read. A temporary filename is generated when not specified.\n Not specifying a filename is only useful for unit tests and demonstrations\n of this library.",
                    "type": "String"
                },
                {
                    "name": "originalCode",
                    "description": "the original code corresponding to the AST,\n used for embedding the source into the coverage object",
                    "type": "String"
                }
            ],
            "class": "Instrumenter"
        },
        {
            "file": "lib/instrumenter.js",
            "line": 503,
            "description": "Callback based instrumentation. Note that this still executes synchronously in the same process tick\nand calls back immediately. It only provides the options for callback style error handling as\nopposed to a `try-catch` style and nothing more. Implemented as a wrapper over `instrumentSync`",
            "itemtype": "method",
            "name": "instrument",
            "params": [
                {
                    "name": "code",
                    "description": "the code to be instrumented as a String",
                    "type": "String"
                },
                {
                    "name": "filename",
                    "description": "Optional. The name of the file from which\n the code was read. A temporary filename is generated when not specified.\n Not specifying a filename is only useful for unit tests and demonstrations\n of this library.",
                    "type": "String"
                },
                {
                    "name": "callback",
                    "description": "- the callback function",
                    "type": "Function(err, instrumentedCode)"
                }
            ],
            "class": "Instrumenter"
        },
        {
            "file": "lib/instrumenter.js",
            "line": 528,
            "description": "returns the file coverage object for the code that was instrumented\njust before calling this method. Note that this represents a\n\"zero-coverage\" object which is not even representative of the code\nbeing loaded in node or a browser (which would increase the statement\ncounts for mainline code).",
            "return": {
                "description": "a \"zero-coverage\" file coverage object for the code last instrumented\nby this instrumenter",
                "type": "Object"
            },
            "class": "Instrumenter"
        },
        {
            "file": "lib/object-utils.js",
            "line": 39,
            "description": "adds line coverage information to a file coverage object, reverse-engineering\nit from statement coverage. The object passed in is updated in place.\n\nNote that if line coverage information is already present in the object,\nit is not recomputed.",
            "itemtype": "method",
            "name": "addDerivedInfoForFile",
            "static": 1,
            "params": [
                {
                    "name": "fileCoverage",
                    "description": "the coverage object for a single file",
                    "type": "Object"
                }
            ],
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 68,
            "description": "adds line coverage information to all file coverage objects.",
            "itemtype": "method",
            "name": "addDerivedInfo",
            "static": 1,
            "params": [
                {
                    "name": "coverage",
                    "description": "the coverage object",
                    "type": "Object"
                }
            ],
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 80,
            "description": "removes line coverage information from all file coverage objects",
            "itemtype": "method",
            "name": "removeDerivedInfo",
            "static": 1,
            "params": [
                {
                    "name": "coverage",
                    "description": "the coverage object",
                    "type": "Object"
                }
            ],
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 148,
            "description": "returns a blank summary metrics object. A metrics object has the following\nformat.\n\n     {\n         lines: lineMetrics,\n         statements: statementMetrics,\n         functions: functionMetrics,\n         branches: branchMetrics\n     }\n\n Each individual metric object looks as follows:\n\n     {\n         total: n,\n         covered: m,\n         pct: percent\n     }",
            "itemtype": "method",
            "name": "blankSummary",
            "static": 1,
            "return": {
                "description": "a blank metrics object",
                "type": "Object"
            },
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 199,
            "description": "returns the summary metrics given the coverage object for a single file. See `blankSummary()`\nto understand the format of the returned object.",
            "itemtype": "method",
            "name": "summarizeFileCoverage",
            "static": 1,
            "params": [
                {
                    "name": "fileCoverage",
                    "description": "the coverage object for a single file.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "the summary metrics for the file",
                "type": "Object"
            },
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 217,
            "description": "merges two instances of file coverage objects *for the same file*\nsuch that the execution counts are correct.",
            "itemtype": "method",
            "name": "mergeFileCoverage",
            "static": 1,
            "params": [
                {
                    "name": "first",
                    "description": "the first file coverage object for a given file",
                    "type": "Object"
                },
                {
                    "name": "second",
                    "description": "the second file coverage object for the same file",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "an object that is a result of merging the two. Note that\n     the input objects are not changed in any way.",
                "type": "Object"
            },
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 250,
            "description": "merges multiple summary metrics objects by summing up the `totals` and\n`covered` fields and recomputing the percentages. This function is generic\nand can accept any number of arguments.",
            "itemtype": "method",
            "name": "mergeSummaryObjects",
            "static": 1,
            "params": [
                {
                    "name": "summary...",
                    "description": "multiple summary metrics objects",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "the merged summary metrics",
                "type": "Object"
            },
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 282,
            "description": "returns the coverage summary for a single coverage object. This is\nwrapper over `summarizeFileCoverage` and `mergeSummaryObjects` for\nthe common case of a single coverage object",
            "itemtype": "method",
            "name": "summarizeCoverage",
            "static": 1,
            "params": [
                {
                    "name": "coverage",
                    "description": "the coverage object",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "summary coverage metrics across all files in the coverage object",
                "type": "Object"
            },
            "class": "ObjectUtils"
        },
        {
            "file": "lib/object-utils.js",
            "line": 299,
            "description": "makes the coverage object generated by this library yuitest_coverage compatible.\nNote that this transformation is lossy since the returned object will not have\nstatement and branch coverage.",
            "itemtype": "method",
            "name": "toYUICoverage",
            "static": 1,
            "params": [
                {
                    "name": "coverage",
                    "description": "The `istanbul` coverage object",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a coverage object in `yuitest_coverage` format.",
                "type": "Object"
            },
            "class": "ObjectUtils"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 13,
            "description": "Facade for all coverage operations support node as well as browser cases\n\nUsage:\n```\n //Node unit tests\n var coverage = require('/path/to/this/file');\n coverage.hookRequire(); // hooks require for instrumentation\n coverage.addInstrumentCandidate(file); // adds a file that needs to be instrumented; should be called before file is `require`d\n\n //Browser tests\n var coverage = require('/path/to/this/file');\n var instrumentedCode = coverage.instrumentFile(file); //alternatively, use `instrumentCode` if you have already loaded the code\n //collect coverage from the browser\n // this coverage will be stored as `window.__coverage__`\n // and...\n coverage.addCoverage(coverageObject); // rinse and repeat\n ```\n\n //in all cases, add an exit handler to the process\n process.once('exit', function () { coverage.writeReports(outputDir); }); //write coverage reports",
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 36,
            "description": "adds a file as a candidate for instrumentation when require is hooked",
            "itemtype": "method",
            "name": "addInstrumentCandidate",
            "params": [
                {
                    "name": "file",
                    "description": "the file to add as an instrumentation candidate"
                }
            ],
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 45,
            "description": "hooks require to instrument all files that have been specified as instrumentation candidates",
            "itemtype": "method",
            "name": "hookRequire",
            "params": [
                {
                    "name": "verbose",
                    "description": "true for debug messages"
                }
            ],
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 61,
            "description": "unhooks require hooks that have been installed",
            "itemtype": "method",
            "name": "unhookRequire",
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 68,
            "description": "returns the coverage collector, creating one if necessary and automatically\nadding the contents of the global coverage object. You can use this method\nin an exit handler to get the accumulated coverage.",
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 88,
            "description": "adds coverage to the collector for browser test cases",
            "params": [
                {
                    "name": "coverageObject",
                    "description": "the coverage object to add"
                }
            ],
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 96,
            "description": "returns the merged coverage for the collector",
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 103,
            "description": "writes reports for an array of JSON files representing partial coverage information",
            "itemtype": "method",
            "name": "writeReportsFor",
            "params": [
                {
                    "name": "fileList",
                    "description": "array of file names containing partial coverage objects"
                },
                {
                    "name": "dir",
                    "description": "the output directory for reports"
                }
            ],
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 118,
            "description": "writes reports for everything accumulated by the collector",
            "itemtype": "method",
            "name": "writeReports",
            "params": [
                {
                    "name": "dir",
                    "description": "the output directory for reports"
                }
            ],
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 136,
            "description": "returns the instrumented version of the code specified",
            "params": [
                {
                    "name": "code",
                    "description": "the code to instrument",
                    "type": "String"
                },
                {
                    "name": "file",
                    "description": "the file from which the code was load",
                    "type": "String"
                }
            ],
            "return": {
                "description": "the instrumented version of the code in the file",
                "type": "String"
            },
            "class": "API"
        },
        {
            "file": "misc/samples/coverage.js",
            "line": 146,
            "description": "returns the instrumented version of the code present in the specified file",
            "params": [
                {
                    "name": "file",
                    "description": "the file to load"
                }
            ],
            "return": {
                "description": "the instrumented version of the code in the file",
                "type": "String"
            },
            "class": "API"
        },
        {
            "file": "index.js",
            "line": 36,
            "description": "the Instrumenter class.",
            "itemtype": "property",
            "name": "Instrumenter",
            "type": "Instrumenter",
            "static": 1,
            "class": "API",
            "module": "istanbul"
        },
        {
            "file": "index.js",
            "line": 42,
            "description": "the Store class.",
            "itemtype": "property",
            "name": "Store",
            "type": "Store",
            "static": 1,
            "class": "API",
            "module": "istanbul"
        },
        {
            "file": "index.js",
            "line": 48,
            "description": "the Collector class",
            "itemtype": "property",
            "name": "Collector",
            "type": "Collector",
            "static": 1,
            "class": "API",
            "module": "istanbul"
        },
        {
            "file": "index.js",
            "line": 54,
            "description": "the hook module",
            "itemtype": "property",
            "name": "hook",
            "type": "Hook",
            "static": 1,
            "class": "API",
            "module": "istanbul"
        },
        {
            "file": "index.js",
            "line": 60,
            "description": "the Report class",
            "itemtype": "property",
            "name": "Report",
            "type": "Report",
            "static": 1,
            "class": "API",
            "module": "istanbul"
        },
        {
            "file": "index.js",
            "line": 66,
            "description": "utility for processing coverage objects",
            "itemtype": "property",
            "name": "utils",
            "type": "ObjectUtils",
            "static": 1,
            "class": "API",
            "module": "istanbul"
        },
        {
            "file": "index.js",
            "line": 72,
            "description": "asynchronously returns a function that can match filesystem paths.\nThe function returned in the callback may be passed directly as a `matcher`\nto the functions in the `hook` module.\n\nWhen no options are passed, the match function is one that matches all JS\nfiles under the current working directory except ones under `node_modules`\n\nMatch patterns are `ant`-style patterns processed using the `fileset` library.\nExamples not provided due to limitations in putting asterisks inside\njsdoc comments. Please refer to tests under `test/other/test-matcher.js`\nfor examples.",
            "itemtype": "method",
            "name": "matcherFor",
            "static": 1,
            "params": [
                {
                    "name": "options",
                    "description": "Optional. Lookup options.",
                    "type": "Object",
                    "props": [
                        {
                            "name": "root",
                            "description": "the root of the filesystem tree under\n    which to match files. Defaults to `process.cwd()`",
                            "type": "String",
                            "optional": true
                        },
                        {
                            "name": "includes",
                            "description": "an array of include patterns to match.\n    Defaults to all JS files under the root.",
                            "type": "Array",
                            "optional": true
                        },
                        {
                            "name": "excludes",
                            "description": "and array of exclude patterns. File paths\n    matching these patterns will be excluded by the returned matcher.\n    Defaults to files under `node_modules` found anywhere under root.",
                            "type": "Array",
                            "optional": true
                        }
                    ]
                },
                {
                    "name": "callback",
                    "description": "The callback that is\n     called with two arguments. The first is an `Error` object in case\n     of errors or a falsy value if there were no errors. The second\n     is a function that may be use as a matcher.",
                    "type": "Function(err, matchFunction)"
                }
            ],
            "class": "API",
            "module": "istanbul"
        },
        {
            "file": "index.js",
            "line": 101,
            "description": "the version of the library",
            "itemtype": "property",
            "name": "VERSION",
            "type": "String",
            "static": 1,
            "class": "API",
            "module": "istanbul"
        }
    ],
    "warnings": [
        {
            "message": "Missing item type\nChunk file size to use when reading non JavaScript files in memory\nand copying them over when using complete-copy flag.",
            "line": " lib/command/instrument.js:22"
        },
        {
            "message": "Missing item type\nWrap a function and make sure it's called only once.",
            "line": " lib/util/flow-control.js:7"
        },
        {
            "message": "Missing item type\nallows writing content to a file using a callback that is passed a content writer",
            "line": " lib/util/writer.js:34"
        },
        {
            "message": "Missing item type\ncopies a file from source to destination",
            "line": " lib/util/writer.js:42"
        },
        {
            "message": "Missing item type\nmarker method to indicate that the caller is done with this writer object\nThe writer is expected to emit a `done` event only after this method is called\nand it is truly done.",
            "line": " lib/util/writer.js:50"
        },
        {
            "message": "Missing item type\nreturns the file coverage object for the code that was instrumented\njust before calling this method. Note that this represents a\n\"zero-coverage\" object which is not even representative of the code\nbeing loaded in node or a browser (which would increase the statement\ncounts for mainline code).",
            "line": " lib/instrumenter.js:528"
        },
        {
            "message": "Missing item type\nFacade for all coverage operations support node as well as browser cases\n\nUsage:\n```\n //Node unit tests\n var coverage = require('/path/to/this/file');\n coverage.hookRequire(); // hooks require for instrumentation\n coverage.addInstrumentCandidate(file); // adds a file that needs to be instrumented; should be called before file is `require`d\n\n //Browser tests\n var coverage = require('/path/to/this/file');\n var instrumentedCode = coverage.instrumentFile(file); //alternatively, use `instrumentCode` if you have already loaded the code\n //collect coverage from the browser\n // this coverage will be stored as `window.__coverage__`\n // and...\n coverage.addCoverage(coverageObject); // rinse and repeat\n ```\n\n //in all cases, add an exit handler to the process\n process.once('exit', function () { coverage.writeReports(outputDir); }); //write coverage reports",
            "line": " misc/samples/coverage.js:13"
        },
        {
            "message": "Missing item type\nreturns the coverage collector, creating one if necessary and automatically\nadding the contents of the global coverage object. You can use this method\nin an exit handler to get the accumulated coverage.",
            "line": " misc/samples/coverage.js:68"
        },
        {
            "message": "Missing item type\nadds coverage to the collector for browser test cases",
            "line": " misc/samples/coverage.js:88"
        },
        {
            "message": "Missing item type\nreturns the merged coverage for the collector",
            "line": " misc/samples/coverage.js:96"
        },
        {
            "message": "Missing item type\nreturns the instrumented version of the code specified",
            "line": " misc/samples/coverage.js:136"
        },
        {
            "message": "Missing item type\nreturns the instrumented version of the code present in the specified file",
            "line": " misc/samples/coverage.js:146"
        }
    ]
}